#################################################################
## SymmetricGroups 
#################################################################

# Note that in Sage, permutations are applied from left to right.
G = SymmetricGroup (5)
sigma = G ( " (1 ,3) (2 ,5 ,4) " )
sigma * sigma

S = SymmetricGroup(5)
A = G('(1,2)(4,5)')
B = G('(1,5,3)(2,4)')
# Apply B first if you want to do A* B. Start from right to left.
B * A

# Function to do right to left composition
def rl(a, b):
    # Do right to left composition
    return b * a  # reverse order

# pg 150 ex 1
S3 = SymmetricGroup(3)
S12 = S3((1, 2))
S13 = S3((1, 3))
S23 = S3((2, 3))
S12 * S13
S123 = S3((1, 2, 3))
rl(S12, S13)

# (23)H = (123)H
rl(S123, S13)
rl(S23, S13)


#################################################################
# Dihedral groups
#################################################################

G = DihedralGroup(4)
list(G)
# 1 ---- 2
# |      |
# 4 ---- 3
G.gens()
G.cayley_table()
# This is representing the symmetries of a square using permutations:


G = DihedralGroup(4)
r, f = G.gens()    # r = rotation, f = reflection

# Define your reflections
F1 = f
F2 = r * f
F3 = r^2 * f
F4 = r^3 * f

# Rotations
R0 = G.identity()
R1 = r
R2 = r^2
R3 = r^3

elements = [R0, R1, R2, R3, F1, F2, F3, F4]
names    = ["R0","R1","R2","R3","F1","F2","F3","F4"]

print("Cayley Table:\n")
print("    " + " ".join(f"{n:>3}" for n in names))

for i, a in enumerate(elements):
    row_label = names[i]
    row = []
    for b in elements:
        product = a * b
        idx = elements.index(product)
        row.append(names[idx])
    print(f"{row_label:>3}  " + " ".join(f"{x:>3}" for x in row))


def name_of(elem):
    idx = elements.index(elem)
    return names[idx]

# page 198 example 12

name_of(R0 * R3)   
name_of(F2 * R1)   
name_of(R0 * R3)
R0 * R3 # gives 270

#   Original:      270 rotation: After (1,4,3,2):
#   1 ---- 2       4 ---- 1
#   |      |       |      |
#   4 ---- 3       3 ---- 2

H = [R0, R2]  # subgroup H = {R0, R3}
for a in elements:
    for h in H:
        product = [name_of(a * h) for h in H]
    print(f"{name_of(a)} * H = {product}")

#################################################################
# My library
#################################################################
import sys
sys.path.insert(0, '/home/alain/Documents/ModAlg/src')

from modalg.groups import U, Z
from modalg.groups import Cartesian, CartesianMatrix

U(10).cyclic(3)
U(10).generators()

print(U(49).group())

# Subgroup of Z_9 generated by 3:
Cartesian([0, 3, 6]).matrix(lambda a, b: (a + b) % 9).to_df()
Cartesian([1, 3]).matrix(lambda a, b: (a + b) % 9).to_df()

# https://www.youtube.com/@babymurcielaga9 

Z9 = Z(9)
Z9.generators()
