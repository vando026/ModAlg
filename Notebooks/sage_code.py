import sys
import os
sys.path.insert(0, os.path.expanduser('~/Documents/Math/ModAlg/src'))

from modalg.groups import U, Z
from modalg.groups import Cartesian, CartesianMatrix

#################################################################
# Utilies
#################################################################
def name_of(elem, elements, names):
    idx = elements.index(elem)
    return names[idx]


#################################################################
# groups
#################################################################

# Find inverse of 13 in Z_20
Z(20).inverse(13)

# Find inverse of 13 in U(14)
U(14).inverse(13)
inverse_mod(13, 14)
(13 * 13) % 14 # is equal to 1


#################################################################
## SymmetricGroups 
#################################################################

# Note that in Sage, permutations are applied from left to right.
G = SymmetricGroup (5)
sigma = G ( " (1 ,3) (2 ,5 ,4) " )
sigma * sigma

S = SymmetricGroup(5)
A = G('(1,2)(4,5)')
B = G('(1,5,3)(2,4)')
# Apply B first if you want to do A* B. Start from right to left.
B * A

# Function to do right to left composition
def rl(a, b):
    # Do right to left composition
    return b * a  # reverse order

# pg 150 ex 1
S3 = SymmetricGroup(3)
S12 = S3((1, 2))
S13 = S3((1, 3))
S23 = S3((2, 3))
S12 * S13
S123 = S3((1, 2, 3))
rl(S12, S13)

# (23)H = (123)H
rl(S123, S13)
rl(S23, S13)

G = SymmetricGroup(4)
g = G("(1,3)(2,4)")
g.tuple()

# Chap 9, Ex 1
G = SymmetricGroup(3)
r, f = G.gens()
r0 = G.identity()
r   # cycle notation
r.tuple() # bottom row
r.dict() # exact mapping


H = [r0, f]
for a in G: 
    for h in H:
        product = [a * h for h in H]
    print(f"{a} * H = {product}")

for a in G: 
    for h in H:
        product = [h * a for h in H]
    print(f"{a} * H = {product}")

# aH neq Ha in general

#################################################################
# Dihedral groups
#################################################################

G = DihedralGroup(4)
list(G)
# 1 ---- 2
# |      |
# 4 ---- 3
G.gens()
G.cayley_table()
# This is representing the symmetries of a square using permutations:


G = DihedralGroup(4)
r, f = G.gens()    # r = rotation, f = reflection

list(G)
# [(), (1,3)(2,4), (1,4,3,2), (1,2,3,4), (2,4), (1,3), (1,4)(2,3), (1,2)(3,4)]


g = G("(1,3)(2,4)") # this is 180 degree rotation
g.tuple()  # this gives bottom row
g.dict() # this gives exact mapping
# 1 2 3 4 
# 3 4 1 2

Compute:
# R0 
r
#R1 or 90 degree rotation
r^2
r180 = r^2
Permutation(r180)
r180.tuple()
r180.dict()
# Horizontal flip
h = G("(1,4)(2,3)")
h.dict()
h.tuple()
# This is the corresponding mapping:
r^2 * f

# R2 * F2
r2f2 = r^2 * (r * f)

# Define your reflections
F1 = f
F2 = r * f
F3 = r^2 * f
F4 = r^3 * f

# Rotations
R0 = G.identity()
R1 = r
R2 = r^2
R3 = r^3

elements = [R0, R1, R2, R3, F1, F2, F3, F4]
names    = ["R0","R1","R2","R3","F1","F2","F3","F4"]

def get_d4(elem): return name_of(elem, elements, names)

get_d4(r2f2)

print("Cayley Table:\n")
print("    " + " ".join(f"{n:>3}" for n in names))

for i, a in enumerate(elements):
    row_label = names[i]
    row = []
    for b in elements:
        product = a * b
        idx = elements.index(product)
        row.append(names[idx])
    print(f"{row_label:>3}  " + " ".join(f"{x:>3}" for x in row))


# page 198 example 12

get_d4(R0 * R3)   
get_d4(F2 * R1)   
get_d4(R0 * R3)
r0r3 = R0 * R3 # gives 270
get_d4(r0r3)
r0r3.tuple()
r0r3.dict()

#   Original:      270 rotation: After (1,4,3,2):
#   1 ---- 2       4 ---- 1
#   |      |       |      |
#   4 ---- 3       3 ---- 2

H = [R0, R2]  # subgroup H = {R0, R3}
for a in elements:
    for h in H:
        product = [get_d4(a * h) for h in H]
    print(f"{get_d4(a)} * H = {product}")

#################################################################
# My library
#################################################################
U(10).cyclic(3)
U(10).generators()

print(U(49).group())

# Subgroup of Z_9 generated by 3:
Cartesian([0, 3, 6]).matrix(lambda a, b: (a + b) % 9).to_df()
Cartesian([1, 3]).matrix(lambda a, b: (a + b) % 9).to_df()

# closed
Cartesian([0, 4, 8, 12]).matrix(lambda a, b: (a + b) % 16).to_df()
# not closed
Cartesian([0, 4, 8, 12]).matrix(lambda a, b: (a + b) % 15).to_df()




# https://www.youtube.com/@babymurcielaga9 

Z9 = Z(9)
Z9.generators() 

#################################################################
# Matrix multiplication in Sage
##################################################################
A = Matrix([[1, 2], [3, 4]])
B = Matrix([[5, 6], [7, 8]])
C = A * B
det(C)

# Example 19, page 46
A = Matrix([[4, 5], [6, 3]])
det(A) % 7 # answer is 3
inv_det = inverse_mod(3, 7)
(inv_det * A.adjugate()) % 7
# Answer is 
# 1 3 
# 5 6 
